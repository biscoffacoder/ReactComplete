React - Open source library for building UI, not a framework.
        React is declarative, React.DOM is supposed to build on what you define.
        npx - npm package runner that gets installed when installing npm. Command to create React app - npx create-react-app fooname
        npm - when using npm alone, we need to install npm globally, command - npm install create-react-app -g, create-react-app fooname;



create react app using - npx create-react-app appname
start react app - npm start
package.json - holds all the dependencies.
if you find any npm issues like ERR:npm missing, run - npm install

index.js    - is the first page to be executed, imports ReactDOM from react-dom. App from ./App
index.html  - the single page that gets loaded from index.js reference which refers to the div id="root".
App.js      - an export functional componenet that contains the information to be rendered in index.js which in turn is being rendered in root id of index.html.

JSX         -   JavaScript XML - HTML code in JS, react transforms this into browser acceptable HTML. Extension to JS language syntax.
                React uses the decalrative approach where we define the desired target state and let React figure out the actual JS DOM instructions.
                JavaScript uses imperative approach where we clearly define all instructions that needs to be executed to generate an element.
                JSX differences - 
                1. Class -> className
                2. for -> htmlFor
                3. camelCasing - onclick->onClick, tabindex -> tabIndex

Component - Part of UI.
            2 types of Componenets - Functional componenet, Class component - 
            Functional componenet - JS functions, do not need to extend React.Component. Can return JSX/HTML
            Class Component - Class extending Conponent Class, render method returning HTML/JSX.
            We can create Functional component, Arrow functional componenet. Both of them work as expected.
            JSX code should always have only 1 root element. Workarounds can be - HOC, additional div. It uses className instead of class.
            Props - properties that can be passed out from higher componenet to children component.
            1. Functional Component -   JS function, optionally receive props, and return HTML/JSX. 
                                        Abscence of "this" keyword, uses different styles to lifecycle hooks, mainly for UI, dumb/presentational.
                                        Props are handled using props.foo Cannot change props- write to props in Components
            
            2. Class Conponent -        ES6 classes, optionally receive props and return HTML/JSX. It can use private state and maintain it.
                                        More feature rich, maintain their own private state, complex UI logic, provides lifecycle hooks, Smart/Containter.
                                        Props are handled using this.props.foo  

            Props vs State - 
            Props - props get passed to the component, function parameters, immutable, Functional components - props.foo, Class Component - this.props
            State - managed within the component, variables decalred in the function body, state can be changed, useState hook in Functional Component, this.state in Class Component.

            State in class component - Create constructor to use state - constructor(){super(); this.state={name:"Allan"}}, using the value - {this.state.name}
            Modifying the state directly without using setState does not rerender the Component, the state may change, but it'll not re-render the component. 
            setState -  To update the state in class component, we can use setState, Calls to setState are asynch. Passing a callback function makes sure that the setState is updated immediately.
                        React may group multiple setState calls into one, to adderess performance issues. This will not guarentee the updation of state using multiple setStates, in 1 cycle. ex - func(){setState//5 times}-- result / setState 5 times but state updation only once.
                        Use the function as an argument to update the state based on previous values. 2nd parameter to the setState can be props.

            Destructuring props -   Usual passing of props - (props) - Use - {props.name}.
                                    
                                    In Functional Components-
                                    Destructuring - (name) - use - {name}
                                    (props) - Destructuring - const {name,heroName}=props;

                                    In Class Conponent - 
                                    Inside render method - Destructuring - const {name,heroName}=this.props;
            
            Event Handling - event handling can be done using onClick, onSubmit etc. they need to be in camelcase, and is handled by - onClick={clickHandler}.
                                If you pass a function call instead of a function, it'll auto run without any effect and may cause infinite re-render.
                                thus always pass a arrow function/ or a function and not a function call. 
                                onClick(()=>{return clickHandler()}). While using arrow syntax we need to provide the function call. as Arrow function will then subsequently call the inner return method.
                                In Class componenet - onClick={this.clickHandler}

            Bind Event Handler - In JS, the this keyword becomes undefined when used inside another function call. for ex - onClick={this.clickHandler}, const clickHandler=()=>{console.log(this)// undefined}.
                                 because of this event binding is necessary as the this keyword does not work as expected.
                                 Binding can be done by 2 methods - 
                                 1. Bind this keyowrd in the render method              - onClick = {this.clickHandler.bind(this)}. It'll now refer to the eventBind. Every update to the state will cause the component to re-render and generate clickHandler again and again. Not performance optimized.
                                 2. Bind using the arrow function in the render method  - onClick = {()=> this.clickHandler()}. This will call the method and return the value. This is also performance down
                                 3. Bind in the constructor                             - In the class component, bind the this keyword to the method directly.
                                                                                          constructor(){this.state={}, this.clickHandler=this.clickHandler.bind(this)}. In the render method we can now call - onClick={this.clickHandler}.
                                                                                          This is the best practice and should be used. because the binding happens only once in the constructor.
                                 4. Define the method using arrow syntax                - In JS, using the arrow function automatically allows this keyword to work as expected. 
                                                                                          clickHandler=()=>{this.setState({})}. No need to define binding in constructor.

            Method as Props -  Child Component calling a method in Parent Component. This can be achieved by passing the method as props to the child component from parent component.
                               Parent Comp -  greetParent(){alert("Hello")} render(){return(<ChildComp greet={this.greetParent})} 
                               Child Comp  - render(){return (<div><button onClick={props.greet}/></div>)}
                               We can also pass parameters from child component using arrow function syntax- <div><button onClick={()=>props.greet("someValue")}/></div> 

      Conditional Rendering -  Rendering data on some conditions, we can use - 1. if/else 2. element variables 3. Ternary conditional operator 4. Short circuit operator
                               1. if/else -  if/else do not work inside the JSX, that's why we need if/else outside the JSX. In Class component - this.setState={isLoggedIn:false}
                                             render(){return (if(this.state.isLoggedIn){return <div>Hi</div>}else{return <div>NO</div>})}

                               2. variables - Inside/outside the render method, define a variable and set the JSX on if/else, and display the variable in JSX, instead of the duplication of code.
                                              let mess = ""; if(this.isLoggedIn){mess = <div>HI</div>}else{mess= <div>NO</div>}
                                              render(){return <div>{mess}</div>}

                                3. Ternary -  It can be used inside the JSX. 
                                              render(){return(this.state.isLoggedIn ? <div>TRUE</div> : <div>FALSE</div>)}

                                4. Short Circuit -  If we want to display only true conditions. we can use short circuit operator. 
                                                    render(){return (this.state.isLoggedIn && <div>HI</div>)}.
                                                    This will check the LHS first and then render RHS. If LHS is false, it'll not render anything.             

        List rendering -        Map can be used to transform each value and return a new array. JSX can be returned using map to generate a dynamic list.
                                const val = ["a","b","c"]. render(){return(<div>{val.map((x)=>{return <h2>{x}</h2>})}</div>)}
                                When rendering a list we need to assign unique key property. This helps react to know which to be rendered again and not the entire list creation again.
                                Key is not accessible in the child component as a prop. It is a reserved keyword. val.map((x)=>{return <h2 key={id}>{x}</h2>})
                                React generates a mutation when new values are added or removed, which means it does not create a new list but checks each key of the item of the list with the changed list and when a key is not found or has been removed, React appends/removes from the relevant index of list. Key prop is necessary here to identify which value has been changed.
        Index as key -          the map arrow function accepts 2 parameter (value, index).  - val.map((value,index)=>{return <h2>{x}</h2>}).
                                Although this can be used, it should be avoided as it can cause various issues, it should only used when list is static, will not be reordered/filtered.

        Style React Component - 1. CSS stylesheets 2. Inline styling 3. CSS Modules 4. CSS in JS library

                                1. CSS stylesheets - create a sheet - mystyles.css, class should be given as - .class{} and used in Component as className="". File should be imported into as import './mystyles.css'
                                                     multiple classes can be used for styling by - `${oneclass} anotherclass`.

                                2. Inline styling  -  define a object with key as the camelcase style property and value as the style value. It can be used in the JSX by - style={object}- 
                                                      const heading ={color:"blue",fontSize:"72px"}. render(){return(<h2 style={heading}>HI</h2>)}                                                   
                                
                                3. Modules Styling - Module can be defined as file - appStyles.module.css and class inside this can be = .success{color:red}, It can be imported into the component by - import styles from 'appStyles.module.css'
                                                     and can be applied inline using - <h2 className={styles.success}/>
                                                     Classes are locally scoped in modules    

        Form Handling -         Controlled Component - When a value is read from a state and on updation the state gets updated and the component re-renders, it's called a Controlled Component
                                                       Form can be controlled using onChange = {}, onSubmit={}, onClick = {}.
                                                       Whenever we try to access or pass the values, it needs to go through event, it is passed as a parameter to the event handler.
                                                       <input type="text" value = {this.state.userName} onChange = {this.handleUserName}>
                                                       handleUserName =(event) =>{console.log(event.target.value)} 


 lifecycle methods - They are present only in class component. They can be divided into 4 reasons - 
                     1. Mounting - When an instance of a component is being created and inserted into the DOM. All Methods - constructor, static getDervivedStateFromProps, render, componentDidMount 
                     2. Updating - When a component is being re-rendered as a result of either update in props or state. All Methods - static getDervivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate
                     3. Unmounting - When a component is being removed from the DOM. All Methods - componentWillUnmount
                     4. Error Handling - When there is an error during rendering in a lifecycle method, or in the constructor of any child component. All Methods - static getDerivedStateFromError, componentDidCatch

                                1. Mounting - In Order of execution - 
                                                1.1 constructor(props) - First call is made to the constructor, a special function that will get called whenever a new component is created.
                                                                         Good for - Initializing state, binding event handlers
                                                                         Bad for  - Do not cause side effects like HTTP requests.
                                                                         Need to call super(props). Only place where we can directly overwrite this.state
                                                1.2 static getDervivedStateFromProps - When the state of the component depends on changes in props over time. Since its a static method, it does not have access to this keyword. Return an object that has the current state.
                                                                                Good for - Set state
                                                                                Bad for - Dont cause side effects like HTTP requests
                                                1.3 render()            - Only required method in the Class component, it is a pure function, it should always render the same UI for a set of state and props.
                                                                          Good for - Read props and state and return JSX
                                                                          Bad for - Do not change state or interact with DOM or make HTTP requests.
                                                                          children component lifecycle methods are also executed in this call. 
                                                1.4 componentDidMount() - Runs only once and is invoked immediately after a component and all its children component have been rendered to the DOM.
                                                                          Good for - Cause side effects like HTTP requests, interact with the DOM.                                                                                  

                                2. Updating - In Order of execution - 
                                                2.1 static getDervivedStateFromProps - Method is called everytime a componentis re-rendered.When the state of the component depends on changes in props over time. Since its a static method, it does not have access to this keyword. Return an object that has the current state.
                                                                                       Good for - Set state
                                                                                       Bad for - Dont cause side effects like HTTP requests
                                                2.2 shouldComponentUpdate(nextProps, nextState) - Method can be used to decide if the component should update or not, decision will cause re-render.
                                                                                                  Good for - performance optimization
                                                                                                  Bad for - Dont cause sideeffects
                                                2.3 render()            - same as above
                                                2.4 getSnapshotBeforeUpdate(prevProps, prevState) - Called right before the changes from the virtual DOM are to be reflected in the DOM.
                                                                                                    Capture some information from the DOM.
                                                2.5 componentDidUpdate(prevProps, prevState, snapshot) - called after render is finished in the re-render cycle
                                                                                                         Good for - Cause side effects

                                3. Unmounting - In Order of execution - 
                                                3.1 componentWillUnmount - Method is invoked immediately before a component is unmounted and destroyed.
                                                                           Good for - Cancelling any network requests, remove event handler, cancel subscriptions invalidate timers
                                                                           Bad for - Dont set state.  

                                4. Error handling -
                                                4.1 static getDerivedStateFromError(error)

                                                4.2 componentDidCatch(error, info) -                                                                                        

React Fragments - Lets you groom child component without adding extra nodes to the DOM. If we want adjacent elements to be rendered, they should always be under one parent element like div. Since adding divs around all children components will add multiple nodes in DOM, to avoid this we will use Fragments.
                  To use this, we can directly use <React.Fragment> <h2></h2><p></p></React.Fragment> instead of traditional <div> and this will not generate additional nodes in DOM.
                  the shorthand syntax is used as - <><h2></h2></> But while using this we can not pass key values. 

Pure Component - Pure Component makes the class component to extend PureCompoenent instead of Component. If a component is created using the PureComponent, it'll only re-render if there's a change in props and state. It achieves this by shallow comparision of both.
                 Ex - class Some extends PureCompoenent.
                 differences - Regular Component - It does not implement the shouldComponentUpdate method, returns true by default.
                               Pure Compoenent   - It implements the shouldComponentUpdate with a shallow props and state comparision. SC of prevProps with currentProps and prevState with currentProps - if false, it'll re-render.
                 Shallow comparision - Primitive types - "a shallow comparision b" returns true if a and b have the same value and are of the same type. Ex - String 'Allan' SC String 'Allan' == true.
                                       Complex types   - "a shallow comparision b" returns true if a and b ref the same object. Ex - var a = [1,2,3], var b = [1,2,3] var c = b; a===b // false, b===c //true.
                 It is a good idea to keep all children component as Pure if Parent is pure.
                 Never mutate the state, always return a new object that reflects the new state.

React.memo     - What PureCompoenent is to class based component, React.memo is to function based component. It is a higher order component.
                 Ex -
                 const fooName = (props)=>{
                 export default React.memo(fooName);
                 }

Refs           - Refs are used to reference the DOM elements and interact with them directly. Refs can be created in 3 steps - 
                 If using a class component, create a ref instance in the constructor for global use. React.createRef(); to create a ref.
                 1. constructor(props){ super(props); this.inputRef = React.createRef();} 
                 Attach this ref to the required DOM element in the render method. It can be attached  using the keyword - ref. Once the ref is created, it'll hold a reference object which will have a property = "current":"input"
                 2. render(){return{<div><input type="text ref={this.inputRef}/></div>}}
                 Call the focus method on this ref to focus the DOM input element.
                 3. componentDidMount(){ this.inputRef.current.focus()}

                 We can also create ref using the callBackRef approach - 
                 create a property and assign it to null in the constructor.
                 1. constructor(props){ super(props); this.cbRef = null;}
                 create a method, which accepts the ref element and assigns it to the property.
                 2. constructor(props){ super(props); this.cbRef = null; this.fooMethod = element =>{this.cbRef = element}}
                 Attach the ref method to the DOM element.
                 3. render(){return{<div><input type="text ref={this.fooMethod}/></div>}}
                 Check if the ref is not null, and then call the focus method. No need to call current here, as it directly accesses the element.
                 4. componentDidMount(){if(this.cbRef){this.cbRef.focus();}}

Refs with Class comp - If we want the parent component to call the focus method inside the child component, we need to create ref in child, create a method that sets the ref in child, assign the ref to a DOM element.
                       Next we need to create a ref in Parent, assign this ref to the child component, create a method to call the focus method of the child component using - this.fooRef.current.fooChildFocus(); the ref in the parent comp will have current access to the child component which will allow it to use the focus method. 
                       Refs cannot be attached to functional component.

Portals - Helps to render elements in such a way that they are not part of the root element.
          It can be created using ReactDOM.createPortal while rendering.

Error Boundary - From the error handling phase methods - static getDerivedStateFromError and componentDidCatch(error,info). We need to use error Boundary so that when there is a error in the app, it does not break. As React will unmounts the whole component Tree. 
                 So error boundary is - a class component that implements either one of both of the lifecycle methods. 
                 The static getDerivedStateFromError is used as a fallback UI after an error is thrown and the componentDidCatch is used to log the error info.
                 error can be thrown from component using - throw new Error("some msg");
                 1. Create a class component ErrorBoundary. 
                 class ErrorBoundary extends Compoenent {
                         constructor(props){
                                 super(props);
                                 this.state={hasError:false}
                         } 
                         static getDerivedStateFromError(error)
                         {
                                 return {
                                         hasError:true;
                                 }
                         }
                         componentDidCatch(error,info)
                         {
                                 console.log(error);
                         }
                         render(){
                                 if(this.state.hasError)
                                 {
                                      return <h1>Something went wrong </h1>   
                                 }
                                 return this.props.children;
                         }
                         }
                 2. Wrap all component with the error boundary in the app.js. This will work only in the production. Not in DEV as it will show all errors to rectify.        
                 <ErrorBoundary>
                 <ChildComp>
                 </ErrorBoundary>
                 Much better would be to wrap each component with ErrorBoundary.
                 ErrorBoundary can catch errors in rendering, lifecycle methods and constructors in the trees below them. They do not catch errors in the action elements like onClick.

higher Order Component - its required to share common functionality between component.
                         A pattern where a function takes a component as an argument and returns a new component.
                         Pass in the original component to function that returns the enhanced component back. 
                         To create an HOC - 
                         1. const updatedComp = (OriginalComponent)=>
                         {
                                 class NewComponent extends React.Component {
                                         const clickCounter=()=>
                                         {
                                                 return 1;
                                         }
                                         render(){return <OriginalComponent name="Allan" click={clickCounter}/>}
                                 }
                         return NewComponent
                         }
                         export default updatedComp

                         2. const ChildComp =(props)=>{
                                 render(){
                                         <div>{props.name} {props.click}</div>

                                 }
                                 export default updatedComp(ChildComp); 
                         }

Render Props - 


React Context - Consider a DOM tree as such - AppComponent -> A, B->C, D->E->F. In this if we want to pass props to A D and F, we need to pass it to its parents as well. If deeply nested, we're providing props to unnecessary components as well.
                Context provides a way to pass data through the component tree without having to pass props down manualy at every level.
                Three steps to use Context -  
                1. Create the Context - 
                        Create a Context Component which will be used to export Consumer and Provider contexts.

                        import React from 'react'
                        const UserContext = React.createContext();
                        const UserProvider = UserContext.Provider
                        const UserConsumer = UserContext.Consumer

                        export {UserProvider,UserConsumer};

                2. Provide a Context Value - 
                        Provide the Context where all children of the components can use it. Therefore App.js is a good place.
                        In App.js wrap the component with the context and pass the props
                        <UserProvider value = "Allan">
                        <Component C/>
                        </UserProvider>


                3. Consume the context value - Since we need to consume in ComponentF, we can use Consumer and provide a function which takes in the props as the parameter and can be returned into a JSX.
                        Thus in ComponentF - 

                        return(){
                                render(
                                        <UserConsumer>
                                        {
                                                (userName)=>{
                                                        return <div> Hello {userName} </div>
                                                }
                                        }
                                        </UserConsumer>
                                )

                        }        

               1. We can set a default value while setting up the context. const UserContext = React.createContext("default value"); Now if we dont use UserProvider in  App.js and still use UserConsumer in ComponentF we will get Hello default Value instead of Hello Allan.
               2. Context type - Need to export UserContext itself, assign this to the contextType method of the class to use in. Now it can be used as this.context. We can also use static contextType = UserContext.
                                 
                                 In UserContext class - 
                                 export default UserContext;
                                 In ComponentE - 
                                 render(){
                                         return(
                                                 <div>
                                                 ComponentE context {this.context}
                                                 <ComponentF/>

                                         )

                                 }  
                                 ComponentE.contextType = UserContext;

React and HTTP - API calls can be made using external HTTP library like axios, fetch library.
                 Add axios by - npm install axios 
                 To use axios calls - 
                 1. create a state property - 
                        constructor(props)
                        {
                                super(props);
                                this.state={posts:[]}

                        }
                2. Make the HTTP call in the componentDidMount lifecycle hook.
                        componentDidMount{
                             axios.get("https://jsonplaceholder.typicode.com/posts")
                             .then(response=>{
                                     console.log(response);
                                     this.setState ({posts:response.data})
                             })
                             .catch(error=>{
                                   console.log(error);  
                             })   
                        }        
                3. Use the state with fetched API values in rendering the JSX.
                        render(){
                                return(
                                        <div>
                                        {posts.map((value)=>{return <div key = {post.id}>
                                        {value}
                                        </div>}
                                        )}
                                        </div>
                                )
                        }

                1. For Post requests - Create the state object as required with properties.
                        constructor(props)
                        {
                                super(props);
                                this.state={
                                        userId='',
                                        userName='',
                                        body=''
                                }
                        }
                2. Create a form and associate the change handlers - 
                        changeHandler = (event)=>{
                                this.setState({[event.target.name]:event.target.value})
                        } 

                        submitHandler = event=>{
                                event.preventDefault();
                                console.log(this.state);
                                axios.post("https://jsonplaceholder.typicode.com/posts",this.state)
                                .then(response=>{
                                        console.log(response)
                                })
                                .error(errorCode=>{
                                        console.log(errorCode)
                                })
                        }

                        render(){
                                return(
                                        <div>
                                        <form onSubmit = {this.submitHandler}>
                                        <div>
                                        <input type='text' name='userId' value={userId} onChange = {this.changeHandler}/>
                                        </div>
                                        <div>
                                        <input type='text' name='userId' value={userId} onChange = {this.changeHandler}/>
                                        </div>
                                        <div>
                                        <input type='text' name='userId' value={userId} onChange = {this.changeHandler}/>
                                        </div>
                                        </form>
                                        </div>

                                )
                        }
                3. Post the request - Make the post request in the submit handler.





